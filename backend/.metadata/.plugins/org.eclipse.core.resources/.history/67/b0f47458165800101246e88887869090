package com.elibrary.bookservice.service;

import com.elibrary.bookservice.dto.BookRequest;
import com.elibrary.bookservice.dto.BookResponse;
import com.elibrary.bookservice.entity.Book;
import com.elibrary.bookservice.exception.ResourceNotFoundException;
import com.elibrary.bookservice.repository.BookRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class BookService {

    private final BookRepository bookRepository;

    @Value("${book.upload.directory}")
    private String uploadDirectory;

    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

    @Transactional
    public BookResponse addBook(BookRequest request, MultipartFile file) throws IOException {
        Book book = new Book();
        book.setTitle(request.getTitle());
        book.setAuthor(request.getAuthor());
        book.setGenre(request.getGenre());
        book.setPublishedDate(request.getPublishedDate());
        book.setNumberOfCopies(request.getNumberOfCopies());
        book.setAvailableCopies(request.getNumberOfCopies());

        String fileName = storeFile(file, request.getTitle());
        book.setFilePath(fileName);
        book.setFileStatus("AVAILABLE");

        return convertToBookResponse(bookRepository.save(book));
    }

    @Transactional
    public BookResponse updateBook(Long id, BookRequest request, MultipartFile file) throws IOException {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found with ID: " + id));

        book.setTitle(request.getTitle());
        book.setAuthor(request.getAuthor());
        book.setGenre(request.getGenre());
        book.setPublishedDate(request.getPublishedDate());

        if (request.numberOfCopies != book.getNumberOfCopies()) {
            int oldTotalCopies = book.getNumberOfCopies();
            int currentAvailableCopies = book.getAvailableCopies();
            int newTotalCopies = request.getNumberOfCopies();

            book.setNumberOfCopies(newTotalCopies);
            int currentlyBorrowed = oldTotalCopies - currentAvailableCopies;
            book.setAvailableCopies(Math.max(0, newTotalCopies - currentlyBorrowed));
        }

        if (file != null && !file.isEmpty()) {
            if (book.getFilePath() != null && !book.getFilePath().isEmpty()) {
                Path oldFilePath = Paths.get(uploadDirectory).resolve(book.getFilePath());
                Files.deleteIfExists(oldFilePath);
            }
            String newFileName = storeFile(file, book.getTitle());
            book.setFilePath(newFileName);
            book.setFileStatus("AVAILABLE");
        }

        return convertToBookResponse(bookRepository.save(book));
    }

    public Page<BookResponse> getAllBooks(Pageable pageable) {
        return bookRepository.findAll(pageable).map(this::convertToBookResponse);
    }

    public List<BookResponse> searchAndFilterBooks(String query, String genre, String author, boolean popularity) {
        List<Book> books;
        if (StringUtils.hasText(query)) {
            books = bookRepository.findByTitleContainingIgnoreCaseOrAuthorContainingIgnoreCaseOrGenreContainingIgnoreCase(query, query, query);
        } else if (StringUtils.hasText(genre)) {
            books = bookRepository.findByGenreContainingIgnoreCase(genre);
        } else if (StringUtils.hasText(author)) {
            books = bookRepository.findByAuthorContainingIgnoreCase(author);
        } else if (popularity) {
            books = bookRepository.findPopularBooks();
        } else {
            books = bookRepository.findAll();
        }
        return books.stream().map(this::convertToBookResponse).collect(Collectors.toList());
    }

    public BookResponse getBookById(Long id) {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found with ID: " + id));
        return convertToBookResponse(book);
    }

    @Transactional
    public void deleteBook(Long id) {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found with ID: " + id));
        if (book.getFilePath() != null && !book.getFilePath().isEmpty()) {
            Path filePath = Paths.get(uploadDirectory).resolve(book.getFilePath());
            try {
                Files.deleteIfExists(filePath);
            } catch (IOException e) {
                System.err.println("Could not delete file for book " + id + ": " + e.getMessage());
            }
        }
        bookRepository.delete(book);
    }

    @Transactional
    public void decrementAvailableCopies(Long bookId) {
        Book book = bookRepository.findById(bookId)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found with ID: " + bookId));
        book.decrementAvailableCopies();
        bookRepository.save(book);
    }

    @Transactional
    public void incrementAvailableCopies(Long bookId) {
        Book book = bookRepository.findById(bookId)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found with ID: " + bookId));
        book.incrementAvailableCopies();
        bookRepository.save(book);
    }

    public Integer getAvailableCopiesCount(Long bookId) {
        return bookRepository.findAvailableCopiesById(bookId)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found or available copies not found for ID: " + bookId));
    }


    private String storeFile(MultipartFile file, String bookTitle) throws IOException {
        String originalFileName = StringUtils.cleanPath(Objects.requireNonNull(file.getOriginalFilename()));
        String fileExtension = originalFileName.contains(".") ? originalFileName.substring(originalFileName.lastIndexOf(".")) : "";
        String uniqueFileName = UUID.randomUUID().toString() + "_" + bookTitle.replaceAll("[^a-zA-Z0-9.-]", "_") + fileExtension;
        Path uploadPath = Paths.get(uploadDirectory).toAbsolutePath().normalize();
        Files.createDirectories(uploadPath);

        Path targetLocation = uploadPath.resolve(uniqueFileName);
        Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
        return uniqueFileName;
    }

    private BookResponse convertToBookResponse(Book book) {
        BookResponse response = new BookResponse();
        response.setId(book.getId());
        response.setTitle(book.getTitle());
        response.setAuthor(book.getAuthor());
        response.setGenre(book.getGenre());
        response.setPublishedDate(book.getPublishedDate());
        response.setFilePath("/books/" + book.getFilePath());
        response.setNumberOfCopies(book.getNumberOfCopies());
        response.setAvailableCopies(book.getAvailableCopies());
        response.setFileStatus(book.getFileStatus());
        return response;
    }
}