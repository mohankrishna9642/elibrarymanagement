package com.elibrary.bookservice.controller;

import java.io.IOException;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.elibrary.bookservice.dto.BookRequest;
import com.elibrary.bookservice.dto.BookResponse;
import com.elibrary.bookservice.service.BookService;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/books")
public class BookController {

    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    // ADMIN ONLY: Add new books
    @PostMapping(consumes = {MediaType.MULTIPART_FORM_DATA_VALUE})
    @PreAuthorize("hasRole('ADMIN')") // Only ADMINs can add books
    public ResponseEntity<BookResponse> addBook(
            @Valid @RequestPart("bookRequest") BookRequest bookRequest,
            @RequestPart("file") MultipartFile file) {
        try {
            BookResponse newBook = bookService.addBook(bookRequest, file);
            return new ResponseEntity<>(newBook, HttpStatus.CREATED);
        } catch (IOException e) {
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // ADMIN ONLY: Modify existing books
    @PutMapping(value = "/{id}", consumes = {MediaType.MULTIPART_FORM_DATA_VALUE})
    @PreAuthorize("hasRole('ADMIN')") // Only ADMINs can modify books
    public ResponseEntity<BookResponse> updateBook(
            @PathVariable Long id,
            @Valid @RequestPart("bookRequest") BookRequest bookRequest,
            @RequestPart(value = "file", required = false) MultipartFile file) {
        try {
            BookResponse updatedBook = bookService.updateBook(id, bookRequest, file);
            return ResponseEntity.ok(updatedBook);
        } catch (IOException e) {
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        } catch (com.elibrary.bookservice.exception.ResourceNotFoundException e) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // ADMIN ONLY: Delete books
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Only ADMINs can delete books
    public ResponseEntity<String> deleteBook(@PathVariable Long id) {
        try {
            bookService.deleteBook(id);
            return ResponseEntity.ok("Book deleted successfully!");
        } catch (com.elibrary.bookservice.exception.ResourceNotFoundException e) {
            return new ResponseEntity<>(e.getMessage(), HttpStatus.NOT_FOUND);
        }
    }

    // ADMIN ONLY: View all books for management
    @GetMapping("/admin/all")
    @PreAuthorize("isAuthenticated()") // Only ADMINs can view this detailed list
    public ResponseEntity<Page<BookResponse>> getAllBooksForAdmin(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<BookResponse> books = bookService.getAllBooks(pageable);
        return ResponseEntity.ok(books);
    }

    // PUBLIC ACCESS: Browse/Search books
    @GetMapping("/browse")
    @PreAuthorize("permitAll()") // Accessible by anyone (authenticated or unauthenticated)
    public ResponseEntity<List<BookResponse>> searchAndFilterBooks(
            @RequestParam(required = false) String query,
            @RequestParam(required = false) String genre,
            @RequestParam(required = false) String author,
            @RequestParam(defaultValue = "false") boolean popularity) {
        List<BookResponse> books = bookService.searchAndFilterBooks(query, genre, author, popularity);
        return ResponseEntity.ok(books);
    }

    // AUTHENTICATED USERS: View a single book's details
    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()") // Requires user to be logged in
    public ResponseEntity<BookResponse> getBookById(@PathVariable Long id) {
        try {
            BookResponse book = bookService.getBookById(id);
            return ResponseEntity.ok(book);
        } catch (com.elibrary.bookservice.exception.ResourceNotFoundException e) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // INTER-SERVICE / ADMIN: Endpoints for Borrowing Service to manage copies
    @PutMapping("/{id}/decrement-copies")
    @PreAuthorize("hasRole('ADMIN')") // Called by Borrowing Service with ADMIN role token
    public ResponseEntity<String> decrementCopies(@PathVariable Long id) {
        bookService.decrementAvailableCopies(id);
        return ResponseEntity.ok("Copies decremented for book " + id);
    }

    @PutMapping("/{id}/increment-copies")
    @PreAuthorize("hasRole('ADMIN')") // Called by Borrowing Service with ADMIN role token
    public ResponseEntity<String> incrementCopies(@PathVariable Long id) {
        bookService.incrementAvailableCopies(id);
        return ResponseEntity.ok("Copies incremented for book " + id);
    }

    @GetMapping("/{id}/available-copies")
    @PreAuthorize("hasRole('ADMIN')") // Called by Borrowing Service with ADMIN role token
    public ResponseEntity<Integer> getAvailableCopies(@PathVariable Long id) {
        Integer availableCopies = bookService.getAvailableCopiesCount(id);
        return ResponseEntity.ok(availableCopies);
    }
}